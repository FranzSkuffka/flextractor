// Generated by CoffeeScript 1.10.0
(function() {
  var incompleteExclusiveRule, incompleteRule, maxRule, minimumRule, zeroRule;

  zeroRule = function(labels, features) {
    var feature, i, inputVector, label, len, outputVector, vectors, zeroVector;
    vectors = [];
    inputVector = [];
    outputVector = [];
    for (feature in features) {
      inputVector.push(0);
    }
    for (i = 0, len = labels.length; i < len; i++) {
      label = labels[i];
      outputVector.push(0);
    }
    zeroVector = {
      input: inputVector,
      output: outputVector
    };
    return [zeroVector];
  };

  maxRule = function(labels, features) {
    var classList, feature, i, inputVector, j, label, len, len1, outputVector, results, targetLabel;
    results = [];
    for (i = 0, len = classes.length; i < len; i++) {
      label = classes[i];
      inputVector = [];
      for (feature in features) {
        classList = features[feature];
        if (classList.indexOf(label.name) > -1) {
          inputVector.push(1);
        } else {
          inputVector.push(0);
        }
      }
      inputMax.push(inputVector);
      outputVector = [];
      for (j = 0, len1 = classes.length; j < len1; j++) {
        targetLabel = classes[j];
        if (label.name === targetLabel.name) {
          outputVector.push(1);
        } else {
          outputVector.push(0);
        }
      }
      results.push(outputMax.push(outputVector));
    }
    return results;
  };

  minimumRule = function(labels, features) {
    var classList, feature, i, inputVector, j, label, len, len1, outputVector, targetLabel, vector, vectorPairs;
    vectorPairs = [];
    for (i = 0, len = labels.length; i < len; i++) {
      label = labels[i];
      inputVector = [];
      outputVector = [];
      for (feature in features) {
        classList = features[feature];
        if (classList.indexOf(label.name) > -1 && label.requires(feature)) {
          inputVector.push(1);
        } else if (classList.indexOf(label.name) > -1) {
          inputVector.push(0);
        } else {
          inputVector.push(0);
        }
      }
      for (j = 0, len1 = labels.length; j < len1; j++) {
        targetLabel = labels[j];
        if (label.name === targetLabel.name) {
          outputVector.push(1);
        } else {
          outputVector.push(0);
        }
      }
      vector = {
        input: inputVector,
        output: outputVector
      };
      vectorPairs.push(vector);
    }
    return vectorPairs;
  };

  incompleteRule = function(labels, features) {
    var classList, feature, i, inputVector, j, label, len, len1, outputVector, targetLabel, vector, vectorPairs;
    vectorPairs = [];
    for (i = 0, len = labels.length; i < len; i++) {
      label = labels[i];
      inputVector = [];
      outputVector = [];
      for (feature in features) {
        classList = features[feature];
        if (classList.indexOf(label.name) > -1 && label.requires(feature)) {
          inputVector.push(0);
        } else if (classList.indexOf(label.name) > -1) {
          inputVector.push(1);
        } else {
          inputVector.push(0);
        }
      }
      for (j = 0, len1 = labels.length; j < len1; j++) {
        targetLabel = labels[j];
        outputVector.push(0);
      }
      vector = {
        input: inputVector,
        output: outputVector
      };
      vectorPairs.push(vector);
    }
    return vectorPairs;
  };

  incompleteExclusiveRule = function(labels, features) {
    var classList, feature, featureIndex, i, inputVector, j, k, label, len, len1, len2, outputVector, requiredFeatureIndex, requiredFeatureIndices, targetLabel, vector, vectorPairs;
    vectorPairs = [];
    for (i = 0, len = labels.length; i < len; i++) {
      label = labels[i];
      outputVector = [];
      for (j = 0, len1 = labels.length; j < len1; j++) {
        targetLabel = labels[j];
        outputVector.push(0);
      }
      featureIndex = 0;
      requiredFeatureIndices = [];
      for (feature in features) {
        classList = features[feature];
        if (classList.indexOf(label.name) > -1 && label.requires(feature)) {
          requiredFeatureIndices.push(featureIndex);
        }
        featureIndex++;
      }
      for (k = 0, len2 = requiredFeatureIndices.length; k < len2; k++) {
        requiredFeatureIndex = requiredFeatureIndices[k];
        inputVector = [];
        featureIndex = 0;
        for (feature in features) {
          classList = features[feature];
          if (classList.indexOf(label.name) > -1) {
            inputVector.push(1);
          }
          if (requiredFeatureIndex === featureIndex) {
            inputVector.pop();
            inputVector.push(0);
          }
          if (classList.indexOf(label.name) < 0) {
            inputVector.push(0);
          }
          featureIndex++;
        }
        vector = {
          input: inputVector,
          output: outputVector
        };
        vectorPairs.push(vector);
      }
    }
    return vectorPairs;
  };

  module.exports = [minimumRule, incompleteRule, incompleteExclusiveRule, zeroRule];

}).call(this);
